# 影院管理系统（TMS）软件详细设计描述文档

## 1. 文档修改历史

| 修改人员 | 日期     | 修改原因                                                     | 版本号 |
| :------: | -------- | ------------------------------------------------------------ | ------ |
|   安皓   | 2019.5.1 | 添加引言、产品概述、体系结构设计概述和依赖视角内容，增加文档修改历史和目录，规定bl模块 | 1.0    |
|   范也   | 2019.5.2 | 添加了MovieServicebl接口的内容                               | 1.1    |
|   安皓   | 2019.5.2 | 在业务逻辑层添加了模块概述、整体结构概述和设计原理概述，完善了Audiencebl模块、Movielikebl模块和Accountbl模块的内容 | 1.2    |
|   范也   | 2019.5.2 | 添加了Movie相关的顺序图和状态图                              | 1.3    |
|  周钰坤  | 2019.5.3 | 完善VIPbl、Purchasebl、Discountbl模块                        | 1.4    |
|  罗民胜  | 2019.5.4 | 完善Adminbl、Staffbl和Arrangebl模块                          | 1.5    |
|   安皓   | 2019.5.4 | 将图和表编号                                                 | 1.6    |

## 2. 目录

<!-- TOC -->

- [影院管理系统（TMS）软件详细设计描述文档](#影院管理系统tms软件详细设计描述文档)
    - [1. 文档修改历史](#1-文档修改历史)
    - [2. 目录](#2-目录)
    - [3. 引言](#3-引言)
        - [3.1 编制目的](#31-编制目的)
        - [3.2 词汇表](#32-词汇表)
        - [3.3 参考资料](#33-参考资料)
    - [4. 产品描述](#4-产品描述)
    - [5. 系统结构设计概述](#5-系统结构设计概述)
    - [6. 结构视角](#6-结构视角)
        - [6.1 业务逻辑层的分解](#61-业务逻辑层的分解)
            - [6.1.1 模块概述](#611-模块概述)
            - [6.1.2 整体结构概述](#612-整体结构概述)
            - [6.1.3 业务逻辑层的设计原理概述](#613-业务逻辑层的设计原理概述)
            - [6.1.4 Audiencebl模块](#614-audiencebl模块)
            - [6.1.5 Adminbl模块](#615-adminbl模块)
            - [6.1.6 Staffbl模块](#616-staffbl模块)
            - [6.1.7 VIPbl模块](#617-vipbl模块)
            - [6.1.8 Purchasebl模块](#618-purchasebl模块)
            - [6.1.9 Movielikebl模块](#619-movielikebl模块)
            - [6.1.10 Accountbl模块](#6110-accountbl模块)
            - [6.1.11 Discountbl模块](#6111-discountbl模块)
            - [6.1.12 MovieServicebl模块](#6112-movieservicebl模块)
            - [6.1.13 Arrangebl模块](#6113-arrangebl模块)
    - [](#)
    - [7. 依赖视角](#7-依赖视角)

<!-- /TOC -->



## 3. 引言

### 3.1 编制目的

	本报告详细完成对影院管理系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。
	
	本报告面向开发人员、测试人员以及最终用户而编写，是了解系统的导航。

### 3.2 词汇表

| 词汇名称 |   词汇含义   |         备注          |
| :------: | :----------: | :-------------------: |
|   TMS    | 影院管理系统 | Theater Manage System |

### 3.3 参考资料

1. 《软件工程与计算(卷二)——软件开发的技术基础》
2. 《影院管理系统(TMS)需求规格说明》
3. 《影院管理系统(TMS)体系结构文档》
4. 《影院管理系统(TMS)用例文档》

## 4. 产品描述

	参考影院管理系统用例文档和影院管理系统需求规格说明文档中对产品的概要描述。

## 5. 系统结构设计概述

 参考影院管理系统(TMS)体系结构文档中对体系结构设计的概述。


## 6. 结构视角

### 6.1 业务逻辑层的分解

	业务逻辑层的开发包图参见影院管理系统(TMS)体系结构文档图4。

#### 6.1.1 模块概述

    各bl模块承担的需求均参见需求规格说明文档功能需求及相关非功能需求。
    
    各bl模块的职责和接口参见体系结构文档7.3.2bl模块的接口规范，比如：
    
    Accountbl模块承担的需求参见需求规格说明文档登录注册的功能需求及相关非功能需求。
    
    Accountbl模块的职责和接口参见体系结构文档7.3.2Accountbl模块的接口规范。
    
    其他不再赘述。

#### 6.1.2 整体结构概述

    根据体系结构的设计，将系统分为了展示层、业务逻辑层和数据层。每一层之间为了增加灵活性，我们会添加接口。以Accountbl为例，在展示层和业务逻辑层之间，我们添加businesslogicservice，即bl.user.AccountService接口；在业务逻辑层和数据层之间，我们添加data.user.AccountMapper接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了AccountController，这样AccountController会将登录注册的业务逻辑委托给AccountServiceImpl对象(即Accountbl)。User作为用户的持久化对象被添加到设计模型。其他功能的业务逻辑大致和Accountbl相同，对于业务逻辑整体结构的补充见下方对应功能bl模块的整体结构。

#### 6.1.3 业务逻辑层的设计原理概述

    利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象，利用不同的领域对象来进行数据传输，以达到展示层、业务逻辑层和数据层之间交互的目的。
    
    其他略。


#### 6.1.4 Audiencebl模块

(1)整体结构

	在设计中，Audiencebl用于分发任务Audience的任务。在观众用户进行登陆后，由Accountbl向Audience发出通知，再由Audiencebl进行任务分发。Audiencebl本身不需要持久化对象数据。
	
	展示层和逻辑层间接口：Audienceblservice
	
	逻辑层和数据层间接口：无
	
	PO：无
	
	Audiencebl模块的设计如图1所示。

<center>图1 Audiencebl各个类的设计</center>	

[![Audiencebl模块各个类的设计.png](https://i.loli.net/2019/05/01/5cc9b25cb5092.png)](https://i.loli.net/2019/05/01/5cc9b25cb5092.png)

	Audiencebl模块各个类的职责如表1所示。

<center>表1 Audiencebl模块各个类的职责</center>


|        模块         | 职责                                                     |
| :-----------------: | -------------------------------------------------------- |
| AudienceController  | 负责实现对应于观众界面所需要的服务                       |
| AudienceServiceImpl | 负责分发任务，调用其他包的对外接口实现观众用户需要的服务 |
(2) 模块内部类的接口规范

	AudienceController和AudienceServiceImpl的接口规范如表2和表3所示。

<center>表2 AudienceController的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">AudienceController.createAudience</td>
    <td>语法</td>
    <td>public ResponseVO createAudience(UserForm audienceForm, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>登录用户为观众</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用AudienceServiceImpl的createAudience方法</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>AudienceServiceImpl.createAudience(UserForm userform)</td>
    <td colspan="2"> <center>创建一个AudienceVO对象并返回</center></td>
  </tr>
  </table>
<center>表3 AudienceServiceImpl的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">AudienceServiceImpl.createAudience</td>
    <td>语法</td>
    <td>public AudienceVO createAudience(UserForm userform)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>登录用户为观众</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>创建一个新的观众用户并返回</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>...</td>
    <td colspan="2"> <center>...</center></td>
  </tr>
  </table>



(3) 业务逻辑层的动态模型

	图x表明了在TMS中观众用户创建的向相关业务逻辑。

<center>图2 创建观众用户的顺序图</center>

[![创建观众对象顺序图.png](https://i.loli.net/2019/05/02/5cca9a6fc8b8e.png)](https://i.loli.net/2019/05/02/5cca9a6fc8b8e.png)

	其他略。

(4) 业务逻辑层的设计原理

	Audiencebl只负责进行任务分发，不需要持久化对象数据。



#### 6.1.5 Adminbl模块

	进行任务分发，与6.1.4 Audiencebl模块类似，参考6.1.4 Audiencebl模块

#### 6.1.6 Staffbl模块

	进行任务分发，与6.1.4 Audiencebl模块类似，参考6.1.4 Audiencebl模块

#### 6.1.7 VIPbl模块

(1)整体结构
	VIPbl模块被用于处理会员相关的业务逻辑，包括购买会员卡、查看会员详情、充值会员余额以及放弃会员资格。模块内包括VIPController及VIPServiceImpl两个模块，VIPController负责响应外部的请求并将请求与VIPServiceImpl的业务实现映射，实现任务分发。VIPPO是作为会员信息的持久化对象被添加到设计模型中。

	展示层和逻辑层间接口：VIPblservice
	
	逻辑层和数据层间接口：VIPdataservice
	
	PO：VIPPO
	
	VIPbl模块的设计如图1所示。

<center>图3 VIPbl各个类的设计</center>	

[![VIPbl模块设计图.png](https://i.loli.net/2019/05/03/5ccc422b45852.png)](https://i.loli.net/2019/05/03/5ccc422b45852.png)

	VIPbl模块各个类的职责如表4所示。

<center>表4 VIPbl模块各个类的职责</center>

|      模块      | 职责                                                   |
| :------------: | ------------------------------------------------------ |
| VIPController  | 负责实现对应于会员界面所需要的服务及模块内部的分发任务 |
| VIPServiceImpl | 负责调用其他包的对外接口，实现会员用户需要的服务       |

(2) 模块内部类的接口规范
	VIPController和VIPServiceImpl的接口规范如表5和表6所示。

<center>表5 VIPController的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">VIPController.createVIP</td>
    <td>语法</td>
    <td>public ResponseMessage createVIP(UserForm audienceForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>观众Audiencbl模块发起创建会员请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用VIPServiceImpl的createVIP方法</td>
  </tr>
<tr>
    <td rowspan="3">VIPController.showVIP</td>
    <td>语法</td>
    <td>public ResponseMessage showVIP(UserForm audienceForm, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>会员观众发起查看会员详情请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用VIPServiceImpl的showVIP方法</td>
  </tr>
  <tr>
    <td rowspan="3">VIPController.rechargeVIP</td>
    <td>语法</td>
    <td>public ResponseMessage rechargeVIP(UserForm audienceForm, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>会员观众发起充值请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用VIPServiceImpl的rechargeVIP方法</td>
  </tr>
  <tr>
    <td rowspan="3">VIPController.paybyVIP</td>
    <td>语法</td>
    <td>public ResponseMessage paybyVIP(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>purchasebl模块发起会员支付请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用VIPServiceImpl的paybyVIP方法</td>
  </tr>
  <tr>
    <td rowspan="3">VIPController.cancelVIP</td>
    <td>语法</td>
    <td>public ResponseMessage cancelVIP(UserForm audienceForm, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>会员观众发起取消会员身份请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用VIPServiceImpl的cancelVIP方法</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>VIPServiceImpl.createVIP(UserForm userform)</td>
    <td colspan="2"> <center>创建一个VIPPO对象并返回一个VIPVO对象</center></td>
  </tr>
  <tr>
    <td>VIPServiceImpl.showVIP(UserForm userform)</td>
    <td colspan="2"> <center>从数据库获取一个VIPPO作为VIPVO对象并返回</center></td>
  </tr>
  <tr>
    <td>VIPServiceImpl.chargeVIP(UserForm userform)</td>
    <td colspan="2"> <center>修改一个VIPPO，并返回提示信息VIPVO</center></td>
  </tr>
  <tr>
    <td>VIPServiceImpl.cancelVIP(UserForm userform)</td>
    <td colspan="2"> <center>删除一个VIPPO数据并返回提示信息</center></td>
  </tr>
  </table>
<center>表6 VIPServiceImpl的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
    <tr>
    <td rowspan="3">VIPServiceImpl.createVIP</td>
    <td>语法</td>
    <td>public ResponseMessage createVIP(UserForm audienceForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个会员创建任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息创建VIPPO对象并插入数据库，返回创建提示</td>
  </tr>
  <tr>
    <td rowspan="3">VIPServiceImpl.showVIP</td>
    <td>语法</td>
    <td>public ResponseMessage showVIP(UserForm audienceForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个VIP信息查询任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息进入数据库查询相应的VIP信息，并返回该信息</td>
  </tr>
  <tr>
    <td rowspan="3">VIPServiceImpl.rechargeVIP</td>
    <td>语法</td>
    <td>public ResponseMessage rechargeVIP(UserForm audienceForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个充值任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息修改对应的余额数据并返回修改提示</td>
  </tr>
 <tr>
    <td rowspan="3">VIPServiceImpl.paybyVIP</td>
    <td>语法</td>
    <td>public ResponseMessage paybyVIP(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个会员支付任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息修改对应的余额数据并返回修改提示</td>
  </tr>
  <tr>
    <td rowspan="3">VIPServiceImpl.cancelVIP</td>
    <td>语法</td>
    <td>public ResponseMessage cancelVIP(UserForm audienceForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个取消会员任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息删除对应的VIP信息，返回提示</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>VIPdataservice.find(int id)</td>
    <td colspan="2"> <center>根据ID进行查找单一持久化对象</center></td>
  </tr>
  <tr>
    <td>VIPdataservice.insert</td>
    <td colspan="2"> <center>插入单一持久化对象</center></td>
  </tr>
  <tr>
    <td>VIPdataservice.update</td>
    <td colspan="2"> <center>更新单一持久化对象</center></td>
  </tr>
  <tr>
    <td>VIPdataservice.delete</td>
    <td colspan="2"> <center>删除单一持久化对象</center></td>
  </tr>
  <tr>
    <td>DatabaseFacory.getVIPDatabase</td>
    <td colspan="2"> <center>得到VIP数据库的服务的引用</center></td>
  </tr>
  </table>

(3) 业务逻辑层的动态模型

下图表明了创建VIP过程中相关对象之间的协作。有关VIP的其他业务的流程图除发起端，其余的协作与创建VIP过程类似，参见此图。

<center>图4 创建VIP的顺序图</center>

[![创建VIP顺序图.png](https://i.loli.net/2019/05/03/5ccc51224ac93.png)](https://i.loli.net/2019/05/03/5ccc51224ac93.png)


下图描述了VIPServiceImpl对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。VIPServiceImpl对象在createVIP或数据库的find方法被调用后进入详情details状态，若无操作则直接进入结束状态；之后随着showVIP方法的进行进入show状态，或recharge和payByVIP两项有关余额的操作进入moneyUpdate状态，或从经过cnacelVIP方法进入结束状态。

<center>图5 VIPService对象状态图</center>

[![VIPServiceImpl状态图.png](https://i.loli.net/2019/05/03/5ccc55ae0144e.png)](https://i.loli.net/2019/05/03/5ccc55ae0144e.png)


(4) 业务逻辑层的设计原理

VIPController负责响应外部的请求并将请求与VIPServiceImpl的业务实现映射，实现任务分发。VIPPO是作为会员信息的持久化对象被添加到设计模型中。


#### 6.1.8 Purchasebl模块

(1)整体结构

Purchasebl负责处理付款、生成订单、查看订单详情业务以及根据订单数据进行的票房统计业务实现。模块内包含PurchaseController、PurchaseServiceImpl两个类，PurchaseController负责相应外部需求同时分发任务，PurchaseServiseImpl负责具体的业务实现，PurchasePO作为订单信息的单一持续对象注入。

展示层和逻辑层间接口：Purchaseblservice

逻辑层和数据层间接口：Purchasedataservice

PO：PurchasePO

Purchasebl模块的设计如图6所示。

<center>图6 Purchasebl各个类的设计</center>	

[![Purchasebl模块设计图.png](https://i.loli.net/2019/05/03/5ccc3ee6ed3cb.png)](https://i.loli.net/2019/05/03/5ccc3ee6ed3cb.png)

Purchasebl模块各个类的职责如表7所示。

<center>表7 Purchasebl模块各个类的职责</center>

|        模块         | 职责                                                   |
| :-----------------: | ------------------------------------------------------ |
| PurchaseController  | 负责实现对应于订单销售所需要的服务及模块内部的分发任务 |
| PurchaseServiceImpl | 负责调用其他包的对外接口，实现订单销售需要的服务       |


(2) 模块内部类的接口规范

	PurchaseController和PurchaseServiceImpl的接口规范如表8和表9所示。

<center>表8 PurchaseController的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseController.createPurchase</td>
    <td>语法</td>
    <td>public ResponseMessage createPurchase(UserForm audienceForm, ArrangeVO arrangeVO , HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>观众点击确认购买，发起创建订单请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用PurchaseServiceImpl的createPurchase方法</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseController.showPurchase</td>
    <td>语法</td>
    <td>public ResponseMessage showPurchase(long id, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>会员观众发起查看订单详情请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用PurchaseServiceImpl的showPurchase方法</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseController.pay</td>
    <td>语法</td>
    <td>public ResponseMessage pay(long id, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>会员观众发起付款请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用PurchaseServiceImpl的pay方法</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseController.statistic</td>
    <td>语法</td>
    <td>public ResponseMessage statistic(MovieVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>movie模块发起票房统计请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用PurchaseServiceImpl的statistic方法</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>PurchaseServiceImpl.createPurchase(UserForm userform, ArrangeVO vo)</td>
    <td colspan="2"> <center>根据用户和排片信息返回一个PurchaseVO对象</center></td>
  </tr>
  <tr>
    <td>PurchaseServiceImpl.showPurchase(long id)</td>
    <td colspan="2"> <center>返回一个PurchaseVO对象</center></td>
  </tr>
  <tr>
    <td>PurchaseServiceImpl.pay(long id)</td>
    <td colspan="2"> <center>根据订单信息进行付款</center></td>
  </tr>
  <tr>
    <td>PurchaseServiceImpl.statistic(MovieVO vo)</td>
    <td colspan="2"> <center>根据电影信息返回对应的电影票房</center></td>
  </tr>
  </table>

<center>表9 PurchaseServiceImpl的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
    <tr>
    <td rowspan="3">PurchaseServiceImpl.createPurchase</td>
    <td>语法</td>
    <td>public ResponseMessage createVIP(UserForm audienceForm, ArrangeVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个订单创建任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据用户信息及排片信息以及调用Discountbl模块折扣信息创建PurchasePO对象并插入数据库，返回创建提示</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseServiceImpl.showPurchase</td>
    <td>语法</td>
    <td>public ResponseMessage showVIP(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个订单信息查询任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据订单号进入数据库查询相应的订单信息，并返回该信息</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseServiceImpl.pay</td>
    <td>语法</td>
    <td>public ResponseMessage pay(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个付款任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据订单id获取订单信息，根据会员信息和银行支付接口完成付款任务，返回提示信息</td>
  </tr>
  <tr>
    <td rowspan="3">PurchaseServiceImpl.statistic</td>
    <td>语法</td>
    <td>public ResponseMessage statistic(MovieVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>启动一个电影票房统计任务</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据电影信息查询并统计该电影的订单销售记录，返回票房信息</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>Purchasedataservice.find(int id)</td>
    <td colspan="2"> <center>根据ID进行查找单一持久化对象</center></td>
  </tr>
  <tr>
    <td>Purchasedataservice.insert</td>
    <td colspan="2"> <center>插入单一持久化对象</center></td>
  </tr>
  <tr>
    <td>DiscountController.getdiscount(MovieVO vo)</td>
    <td colspan="2"> <center>获取电影折扣信息</center></td>
  </tr>
  <tr>
    <td>VIPController.paybyVIP</td>
    <td colspan="2"> <center>提供会员支付服务</center></td>
  </tr>
  <tr>
    <td>DatabaseFacory.getVIPDatabase</td>
    <td colspan="2"> <center>得到VIP数据库的服务的引用</center></td>
  </tr>
  </table>

(3) 业务逻辑层的动态模型

下图表明了支付过程中相关对象之间的协作。有关Purchase的其他业务的流程图的协作与支付过程类似，不会复杂于支付，则参见此图。

<center>图7 支付的顺序图</center>

[![支付顺序图.png](https://i.loli.net/2019/05/03/5ccc51224b908.png)](https://i.loli.net/2019/05/03/5ccc51224b908.png)


下图描述了PurchaseServiceImp对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。

<center>图8 Purchase对象状态图</center>

[![PurchaseServiceImpl状态图.png](https://i.loli.net/2019/05/03/5ccc55adf3bb7.png)](https://i.loli.net/2019/05/03/5ccc55adf3bb7.png)



(4) 业务逻辑层的设计原理

PurchaseController负责相应外部需求同时分发任务，PurchaseServiseImpl负责具体的业务实现，PurchasePO作为订单信息的单一持续对象注入。

#### 6.1.9 Movielikebl模块

(1)整体结构

	在设计中，Movielikebl用于处理想看电影的相关逻辑。MovielikePO作为想看电影的记录的持久化对象被添加到设计模型中。
	
	逻辑层和数据层间接口：MovielikMapper
	
	PO：MovieLike
	
	Movielikebl模块的设计如图9所示。

<center>图9 Movielikebl模块各个类的设计</center>

[![Movielikebl模块各个类的设计.png](https://i.loli.net/2019/05/02/5cca7183794a4.png)](https://i.loli.net/2019/05/02/5cca7183794a4.png)

	Movielikebl模块各个类的职责如表10所示。

<center>表10 Movielikebl模块各个类的职责</center>

|         模块         | 职责                                                         |
| :------------------: | ------------------------------------------------------------ |
| MovielikeServiceImpl | 负责实现对应于想看电影的相关逻辑，包括标记电影为想看、取消想看和统计电影想看人数，封装了MovielikeItem的数据集合的数据结构 |


(2) 模块内部类的接口规范

	MovielikeServiceImpl的接口规范如表11所示。
<center>表11 MovielikeServiceImpl的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">MovielikeServiceImpl.getLikeNum</td>
    <td>语法</td>
    <td>public Integer getLikeNum(long movieid)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影在数据库中存在</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回电影的想看人数</td>
  </tr>
  <tr>
    <td rowspan="3">MovielikeServiceImpl.getLikeMovieList</td>
    <td>语法</td>
    <td>public Integer getLikeMovieList(long userid)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回所有被用户标记为想看的电影</td>
  </tr>
  <tr>
    <td rowspan="3">MovielikeServiceImpl.Mapping</td>
    <td>语法</td>
    <td>public ResultMessage Mapping(long movieid,long userid)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影在数据库中存在</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>添加用户和电影的映射</td>
  </tr>
  <tr>
    <td rowspan="3">MovielikeServiceImpl.IsLike</td>
    <td>语法</td>
    <td>public Boolean Islike(long movieid,long userid)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影在数据库中存在</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>若用户已标记电影为想看，返回true，反之返回false</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>MovielikeMapper.getUserList(long movieid)</td>
    <td colspan="2"> <center>根据电影id查找所有的User</center></td>
  </tr>
  <tr>
    <td>MovielikeMapper.getMovieList(long userid)</td>
    <td colspan="2"> <center>根据用户id查找所有被用户标记为想看的电影</center></td>
  </tr>
  <tr>
    <td>MovielikeMapper.Mapping(long movieid,long userid)</td>
    <td colspan="2"> <center>增加/取消用户的想看电影记录</center></td>
  </tr>
  <tr>
    <td>MovielikeMapper.Islike(long movieid,long userid)</td>
    <td colspan="2"> <center>返回用户是否标记电影为想看</center></td>
  </tr>
  </table>



(3) 业务逻辑层的动态模型

	图10表明了获取想看人数的相关逻辑。

<center>图10 获取想看人数的顺序图</center>

[![获取想看人数顺序图.png](https://i.loli.net/2019/05/02/5cca9a701081a.png)](https://i.loli.net/2019/05/02/5cca9a701081a.png)

	获取想看电影列表的过程和获取想看人数类似，只是参数变为long userid。
	
	获取是否想看的过程和获取想看人数类似，只是参数变为long movieid, long userid。
	
	图y表明了映射想看的相关业务逻辑。

<center>图11 映射想看的顺序图</center>

[![映射顺序图.png](https://i.loli.net/2019/05/02/5cca9a6feba10.png)](https://i.loli.net/2019/05/02/5cca9a6feba10.png)

    如图x所示的状态图描述了Movielikebl对象的生存周期的状态序列、引起转移的事件，以及因状态转移而伴随的动作。随着Mapping方法被调用，Account进入Movielike状态；在Movielike状态下通过getLikeMovieList方法进入logged状态，在MovielikeList状态下通过getLikeNum方法进入MovielikeNum状态。

<center>图12 Movielikebl对象状态图</center>

[![movielikebl状态图.png](https://i.loli.net/2019/05/02/5ccaac8542c2b.png)](https://i.loli.net/2019/05/02/5ccaac8542c2b.png)

(4) 业务逻辑层的设计原理

	由Audience/Manager/Admin向Movielikebl分发任务，再由Movielike的控制器委托给MovielikePO进行业务逻辑层和数据层的交互。



#### 6.1.10 Accountbl模块

(1)整体结构

	在设计中，Accountbl用于登录注册的相关逻辑。User作为用户的记录的持久化对象被添加到设计模型中。
	
	展示层和逻辑层间接口：AccountService
	
	逻辑层和数据层间接口：AccountMapper
	
	PO：User
	
	Accountbl模块的设计如图7所示。

<center>图13 Accountbl模块各个类的设计</center>

[![Accountbl模块各个类的设计.png](https://i.loli.net/2019/05/01/5cc9b25ca02a3.png)](https://i.loli.net/2019/05/01/5cc9b25ca02a3.png)

	Accountbl模块各个类的职责如表7所示。

<center>表12 Movielikebl模块各个类的职责</center>

|        模块        | 职责                                   |
| :----------------: | -------------------------------------- |
| AccountController  | 负责实现对应于登录注册界面所需要的服务 |
| AccountServiceImpl | 负责实现对应于登录注册功能所需要的服务 |


(2) 模块内部类的接口规范

	AccountController和AccountServiceImpl的接口规范如表13和表1$所示。

<center>表13 AccountController的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">AccountController.login</td>
    <td>语法</td>
    <td>public ResponseVO login(UserForm userForm, HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用AccountServiceImpl的login方法</td>
  </tr>
  <tr>
    <td rowspan="3">AccountController.registerAccount</td>
    <td>语法</td>
    <td>public ResponseVO login(UserForm userForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用AccountServiceImpl的registerAccount方法</td>
  </tr>
   <tr>
    <td rowspan="3">AccountController.logOut</td>
    <td>语法</td>
    <td>public String logOut(HttpSession session)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>用户已经登录</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回主页地址</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>AccountServiceImpl.login(UserForm userform)</td>
    <td colspan="2"> <center>判断用户名密码是否已经在数据库中且是否匹配</center></td>
  </tr>
  <tr>
    <td>AccountServiceImpl.registerAccount(UserForm userform)</td>
    <td colspan="2"> <center>判断用户名密码是否已经在数据库中，在数据库中添加用户记录</center></td>
  </tr>
  </table>

<center>表14 AccountServiceImpl的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">AccountServiceImpl.login</td>
    <td>语法</td>
    <td>public UserVO login(UserForm userForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回用户的VO，用户名密码不匹配时为null</td>
  </tr>
   <tr>
    <td rowspan="3">AccountServiceImpl.registerAccount</td>
    <td>语法</td>
    <td>public ResponseVO registerAccount(UserForm userForm)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>创建新的用户对象</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>AccountMapper.createNewAccount(UserForm userForm)</td>
    <td colspan="2"> <center>在数据库中创建新的用户对象</center></td>
  </tr>
  <tr>
    <td>AccountMapper.getAccountByName(UserForm userForm)</td>
    <td colspan="2"> <center>根据用户名在数据库中查找用户对象并返回</center></td>
  </tr>
  </table>


(3) 业务逻辑层的动态模型

	图14表明了登录的相关逻辑。

<center>图14 登录的顺序图</center>

[![登录顺序图.png](https://i.loli.net/2019/05/02/5cca9a70189b1.png)](https://i.loli.net/2019/05/02/5cca9a70189b1.png)

	图15表明了注册的相关逻辑。

<center>图15 注册的顺序图</center>

[![注册顺序图.png](https://i.loli.net/2019/05/02/5cca9a7002741.png)](https://i.loli.net/2019/05/02/5cca9a7002741.png)



	如图16所示的状态图描述了Accountbl对象的生存周期的状态序列、引起转移的事件，以及因状态转移而伴随的动作。随着login/registerAccount方法被AccountUI调用，Account进入Login/Register状态；在Login状态下通过login方法进入logged状态，在Register状态下通过registerAccount方法进入Login状态，在logged状态下通过logOut方法进入loggin状态。

<center>图16 Accountbl对象状态图</center>

[![Accountbl状态图.png](https://i.loli.net/2019/05/02/5ccaaad6bf209.png)](https://i.loli.net/2019/05/02/5ccaaad6bf209.png)



(4) 业务逻辑层的设计原理

	Account界面所需要访问的业务逻辑由Account的控制器委托给不同的领域对象，即UserVO、UserForm和User。



#### 6.1.11 Discountbl模块

(1)整体结构

Discountbl模块负责折扣信息的存取及员工发布优惠策略的业务实现，模块内仅有Discountservic一个类，DiscountPO作为优惠信息的持久化对象注入。

展示层和逻辑层间接口：无

	逻辑层和数据层间接口：Discountdataservice
	
	PO：DiscountPO

Discountbl模块的设计如图1所示。

<center>图17 Discountbll各个类的设计</center>	

[![Discountbl模块设计图.png](https://i.loli.net/2019/05/03/5ccc3ee6dcc8a.png)](https://i.loli.net/2019/05/03/5ccc3ee6dcc8a.png)

	Discountbl模块各个类的职责如表22所示。

<center>表15 Discountbl模块各个类的职责</center>


|      模块       | 职责                                           |
| :-------------: | ---------------------------------------------- |
| DiscountService | 负责实现员工发布优惠及订单付款参考所需要的服务 |


(2) 模块内部类的接口规范

DiscountService的接口规范如表16所示。

<center>表16 DiscountService的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">DiscountService.createDiscount</td>
    <td>语法</td>
    <td>public ResponseVO createDiscount(DiscountVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>Staffbl发起创建优惠请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>创建DiscountPO,并返回提示信息</td>
  </tr>
    <tr>
    <td rowspan="3">DiscountService.deleteDiscount</td>
    <td>语法</td>
    <td>public ResponseVO deleteDiscount(MovieVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>Staffbl发起结束优惠请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>删除DiscountPO数据,并返回提示信息</td>
  </tr>
    <tr>
    <td rowspan="3">DiscountService.getDiscount</td>
    <td>语法</td>
    <td>public ResponseVO getDiscount(MovieVO vo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>purchase发起优惠查询请求</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>根据电影查询对应的优惠信息,并返回提示信息</td>
  </tr>
  </tr>
      <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>Discountdataservice.find(int id)</td>
    <td colspan="2"> <center>根据ID进行查找单一持久化对象</center></td>
  </tr>
  <tr>
    <td>Discountdataservice.insert</td>
    <td colspan="2"> <center>插入单一持久化对象</center></td>
  </tr>
  <tr>
    <td>Discountdataservice.insert</td>
    <td colspan="2"> <center>获取电影折扣信息</center></td>
  </tr>
  <tr>
    <td>DatabaseFacory.getDiscountDatabase</td>
    <td colspan="2"> <center>得到Discount数据库的服务的引用</center></td>
  </tr>
  </table>



(3) 业务逻辑层的动态模型


下图表明了创建优惠过程中相关对象之间的协作。有关Discount的其他业务的流程图除发起端，其余的协作与创建优惠过程类似，参见此图。

<center>图18 创建VIP的顺序图</center>

[![发布优惠顺序图.png](https://i.loli.net/2019/05/03/5ccc51224b319.png)](https://i.loli.net/2019/05/03/5ccc51224b319.png)


下图描述了DiscountService对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。

<center>图19 DiscountService的状态图</center>

[![DiscountServiceImpl状态图.png](https://i.loli.net/2019/05/03/5ccc55adf20be.png)](https://i.loli.net/2019/05/03/5ccc55adf20be.png)


(4) 业务逻辑层的设计原理

DiscountService类负责实现业务，DiscountPO作为优惠信息的持久化对象注入。

#### 6.1.12 MovieServicebl模块

(1)整体结构

    MovieServicebl负责处理电影数据。为了增强系统的内聚性，我们把对于电影和电影列表的筛选、统计、排序、增加、删除、获取都放入MovieServicebl包中。其中对于单个Movie的获取，由Movie类负责，对于一个电影列表的获取，由MovieList负责。对于Movie的搜索，由Search类负责,对于Movie的统计，由Statistic类负责。Statistic和Search共同实现filter接口和sort接口。对于电影数据库的增删改查，由Manage类负责。

Movie和MovieList作为持久化数据被保存在bl层

展示层与逻辑层接口：MovieblService

逻辑层与数据层接口：MovieMapper

PO：MoviePO

VO：MovieVO

MovieServicebl模块的设计如图20所示。

<center>图20 MovieServicebl模块各个类的设计</center>

[![未命名文件 (1).png](https://i.loli.net/2019/05/02/5cca9f7525788.png)](https://i.loli.net/2019/05/02/5cca9f7525788.png)

	MovieServicebl模块各个类的职责如表x所示。

<center>表17 MovieServicebl模块各个类的职责</center>

|       模块        | 职责                                                     |
| :---------------: | -------------------------------------------------------- |
|  MovieController  | 负责实现对应于电影详情或列表界面所需要的服务             |
|       Movie       | 负责实现对应于单个电影数据所需要的服务                   |
|     MovieList     | 负责实现对应于登录注册功能所需要的服务                   |
| AccountController | 负责实现对应于多个电影的数据获取、查看和修改所需要的服务 |
|      Search       | 负责实现对应于搜索功能所需要的服务                       |
|     Statistic     | 负责实现对应于统计功能所需要的服务                       |

(2) 模块内部类的接口规范

<center>表18 MovieController的接口规范</center>

<table border="1">
  <tr>
    <td colspan="3"><center>提供的服务（供接口）</center></td>
  </tr>
  <tr>
    <td rowspan="3">MovieController.search</td>
    <td>语法</td>
    <td>public MovieVO search(String keyword)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回电影的VO列表</td>
  </tr>
  <tr>
    <td rowspan="3">MovieController.statistic</td>
    <td>语法</td>
    <td>public StaVO statistic(String statype)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回统计数据</td>
  </tr>
  <tr>
    <td rowspan="3">MovieController.getMovie</td>
    <td>语法</td>
    <td>public MovieVO getMovie(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回MovieVO</td>
  </tr>
  <tr>
    <td rowspan="3">MovieController.getMovieList</td>
    <td>语法</td>
    <td>public MovieVO[] getMovieList(long[] id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回MovieVO[]</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.getMovie</td>
    <td>语法</td>
    <td>public Movie getMovie(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取Movie对象</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.getPrice</td>
    <td>语法</td>
    <td>public int getPrice(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取Movie的价格</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.getArrangeInfo</td>
    <td>语法</td>
    <td>public Info[] getArrangeInfo(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取Movie排片信息</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.update</td>
    <td>语法</td>
    <td>public void update(Movie mo, long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>增加或修改movie数据库对象</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.getBoxOffice</td>
    <td>语法</td>
    <td>public BoxOffice getBoxOffice(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取Movie票房(购买次数和总收益)</td>
  </tr>
  <tr>
    <td rowspan="3">Movie.getDetail</td>
    <td>语法</td>
    <td>public String[] getDetail(long id)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取电影详情（名称、导演、演员、标签）</td>
  </tr>
  <tr>
    <td rowspan="3">MovieList.getMovieList</td>
    <td>语法</td>
    <td>public Movie[] getMovieList(long id[])</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回获取Movie列表</td>
  </tr>
  <tr>
    <td rowspan="3">Filter.filter(Movie[] mo)</td>
    <td>语法</td>
    <td>public Movie[] filter(Movie[] mo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回过滤后的Movie列表</td>
  </tr>
  <tr>
    <td rowspan="3">Sort.sort</td>
    <td>语法</td>
    <td>public Movie[] sort(Movie[] mo)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>无</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回排序后的Movielist</td>
  </tr>
  <tr>
    <td colspan="3"><center>需要的服务（需接口）</center></td>
  </tr>
  <tr>
    <td>服务名</td>
    <td colspan="2"><center>服务</center></td>
  </tr>
  <tr>
    <td>MovieMapper.update(MoviePO movie,long id)</td>
    <td colspan="2"> <center>在数据库上架电影列表中创建新的电影对象</center></td>
  </tr>
  <tr>
    <td>MovieMapper.update(MoviePO movie[])</td>
    <td colspan="2"> <center>在数据库上架电影列表中创建新的电影对象列表</center></td>
  </tr>
  <tr>
    <td>MovieMapper.delete(long id)</td>
    <td colspan="2"> <center>在数据库下架电影</center></td>
  </tr>
  <tr>
    <td>MovieMapper.delete(long id[])</td>
    <td colspan="2"> <center>在数据库下架电影列表</center></td>
  </tr>
  <tr>
    <td>MovieMapper.search(long id)</td>
    <td colspan="2"> <center>在数据库中搜索电影</center></td>
  </tr>
  <tr>
    <td>MovieLike.likedNum(long movieid)</td>
    <td colspan="2"> <center>得到电影的想看人数</center></td>
  </tr>
  <tr>
    <td>Arrange.arrangeInfo(long movieid)</td>
    <td colspan="2"> <center>得到电影的价格、排片、影厅信息</center></td>
  </tr>
  <tr>
    <td>Purchase.boxOffice(long movieid)</td>
    <td colspan="2"> <center>得到电影的票房信息</center></td>
  </tr>
  </table>

(3) 业务逻辑层的动态模型
[![未命名文件 (2).png](https://i.loli.net/2019/05/03/5ccbc965c472a.png)](https://i.loli.net/2019/05/03/5ccbc965c472a.png)

<center>图21 查看电影详情的顺序图</center>

[![未命名文件 (3).png](https://i.loli.net/2019/05/03/5ccc176c23abe.png)](https://i.loli.net/2019/05/03/5ccc176c23abe.png)

<center>图22 上架电影的顺序图</center>

[![未命名文件 (4).png](https://i.loli.net/2019/05/03/5ccc3c89a3b5b.png)](https://i.loli.net/2019/05/03/5ccc3c89a3b5b.png)

<center>图23 搜索电影的顺序图</center>

[![未命名文件 (5).png](https://i.loli.net/2019/05/03/5ccc3d00206e6.png)](https://i.loli.net/2019/05/03/5ccc3d00206e6.png)

<center>图24 统计电影信息的顺序图</center>

[![未命名文件 (6).png](https://i.loli.net/2019/05/03/5ccc408992c1c.png)](https://i.loli.net/2019/05/03/5ccc408992c1c.png)

<center>图25 MovieServicebl状态图</center>



(4) 业务逻辑层的设计原理

对于电影的增删改查，以及对于电影属性的查看，都由Movie和MovieList负责，Movie对于属性的访问，不需要自己访问数据库，而是通过调用其他模块访问电影的属性，这样减少了开发时间。

对于电影的搜索和统计，因为都需要对电影库进行筛选和排序，所以要实现两个接口：filter、sort。这样可以满足后续各种不同的扩展功能（包括根据不同属性对电影进行统计或者搜索）。

通过MovieblService调用MovieController分发任务。

#### 6.1.13 Arrangebl模块

(1)整体结构

在Arrangebl模块设计中，展示层与逻辑层之间添加ArrangeBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了ArrangeController, 当任务分发之后ArrangeController就会将排片的业务逻辑处理委托给内部实现类ArrangeblserviceImpl对象，然后由ArrangeblserviceImpl对象进一步处理任务。ArrangePO作为持续化对象被ArrangeList永久保存。ArrangeLIst封装了关于ArrangeItem的数据结构的秘密和排片信息。

Arrangebl模块的设计如下图所示。
<center>图26 Arrangebl模块各个类的设计</center>
![](https://img-blog.csdnimg.cn/2019050412431190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxMjYxOA==,size_16,color_FFFFFF,t_70)

<center>Arrangebl模块各个类的设计</center>

Arrangebl模块各个类的职责如表y所示。
<center><b> Arrangebl模块各个类的职责</b></center>

| 模块                 | <center>职责</center>                                        |
| :------------------- | :----------------------------------------------------------- |
| LoginController      | 负责实现对应于登录界面所需要的服务                           |
| ArrangeController    | 负责实现排片界面所需要的服务                                 |
| ArrangeblserviceImpl | 作为内部类，实现排片所需的接口，负责完成排片业务逻辑处理的服务 |

(2) 模块内部类的接口规范
ArrangeControlle 和 ArrangeblserviceImpl 的接口规范如下两个表所示。

<center><b>ArrangeController的接口规范</b><center>  
<table border="1">
  <tr>
    <td colspan="3"><center><b>提供的服务（供接口）</b></center></td>
  </tr>
  <tr>
    <td rowspan="3">ArrangeController.addArrangeInfo</td>
    <td>语法</td>
    <td>public ResultMessage addArrangeInfo(long movieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的addArrangeInfo(long movieID)方法</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public ArrangeItem viewArrangeInfo(long mivieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的viewArrangeInfo(long movieID)方法</td>
  </tr>
  <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public List&lt; ArrangeItem&gt;  viewArrangeInfo(Date startDate)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的viewArrangeInfo(Date startDate)方法</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public List&lt; ArrangeItem&gt;  viewArrangeInfo(long hallID, Date startDate)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的viewArrangeInfo(long hallID, Date startDate)方法</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.deleteArrangeInfo</td>
    <td>语法</td>
    <td>public ResultMessage deleteArrangeInfo(long mivieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的deleteArrangeInfo(long mivieID)方法</td>
  </tr>
 <tr>
    <td rowspan="3">ArrangeController.setVisibleTime</td>
    <td>语法</td>
    <td>public ResultMessage setVisibleTime(long movieID, Date startDate, Date endDate)
  </tr>
   <tr>
    <td>前置条件</td>
    <td>已创建一个ArrangeblserviceImpl对象</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>调用ArrangeblserviceImpl领域对象的setVisibleTime(long movieID, Date startDate, Date endDate)方法</td>
  </tr>
  <tr>
  <td colspan="3"><center><b>需要的服务（需接口）</b></center></td>
  </tr>
  <tr>
 <td colspan="3"><center>ArrangeblserviceImpl提供的接口即为ArrangeController的需接口</center></td>
  </tr>
  </table>
  

<center><b>表19 ArrangeblserviceImpl的接口规范</b><center>  
<table border="1">
  <tr>
    <td colspan="3"><center><b>提供的服务（供接口）</b></center></td>
  </tr>
  <tr>
    <td rowspan="3">ArrangeController.addArrangeInfo</td>
    <td>语法</td>
    <td>public ResultMessage addArrangeInfo(long movieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影ID合法有效，并且排片列表中没有该电影的排片信息</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>排片列表中存在该电影的排片信息，用户可以看到</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public ArrangeItem viewArrangeInfo(long mivieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影ID合法有效，并且排片列表中真实存在该电影的排片信息</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>得到针对目标电影的排片信息，包括目标电影在各个影厅近7天的排片情况</td>
  </tr>
  <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public List&lt; ArrangeItem&gt;  viewArrangeInfo(Date startDate)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>参数日期合法有效，且时间比系统时间提前，也就是说不能是过去的时间，当然也不能超出排片的最晚时间</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回在起始时间包括近七天的排片列表</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.viewArrangeInfo</td>
    <td>语法</td>
    <td>public List&lt; ArrangeItem&gt;  viewArrangeInfo(long hallID, Date startDate)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>影厅ID合法有效，起始时间比系统时间提前，但不超过排片的最晚时间</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>返回一个目标影厅在目标时间段的排片列表</td>
  </tr>
   <tr>
    <td rowspan="3">ArrangeController.deleteArrangeInfo</td>
    <td>语法</td>
    <td>public ResultMessage deleteArrangeInfo(long mivieID)</td>
  </tr>
  <tr>
    <td>前置条件</td>
    <td>电影ID合法有效，且目标电影已经在排片列表中</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>排片列表中没有目标电影的排片信息</td>
  </tr>
 <tr>
    <td rowspan="3">ArrangeController.setVisibleTime</td>
    <td>语法</td>
    <td>public ResultMessage setVisibleTime(long movieID, Date startDate, Date endDate)
  </tr>
   <tr>
    <td>前置条件</td>
    <td>首先电影ID合法有效，起始时间格式满足要求0000-00-00，起始时间必须小于终止时间，起始时间提前于系统时间， 终止时间不能晚于电影的最晚排片时间</td>
  </tr>
  <tr>
    <td>后置条件</td>
    <td>得到目标电影在目标时间段的排片信息，包括场次，影厅等</td>
  </tr>
  <tr>
  <td colspan="3"><center><b>需要的服务（需接口）</b></center></td>
  </tr>
  <tr>
  <tr>
    <td><center>服务名</center></td>
    <td colspan="2"><center>服务</center></td>
  </tr>
   <tr>
    <td>ArrangeDataService.find(long mivieID)</td>
    <td colspan="2">根据电影ID进行查找单一持久化对象</td>
   </tr>
    <tr>
    <td>ArrangeDataService.finds(String field, int value)</td>
    <td colspan="2">根据字段名和值进行查找多个持久化对象</td>
   </tr>
    <tr>
    <td>ArrangeDataService.insert(ArrangePO po)</td>
    <td colspan="2">插入单一持久化对象</td>
   </tr>
    <tr>
    <td>ArrangeDataService.delete(ArrangePO po)</td>
    <td colspan="2">删除单一持久化对象</td>
   </tr>
    <tr>
    <td>ArrangeDataService.delete(ArrangePO po)</td>
    <td colspan="2">更新单一持久化对象</td>
   </tr>
   <tr>
    <td>Database.getArrangeDatabase</td>
    <td colspan="2">得到Arrange数据库的服务的引用</td>
   </tr>
   <tr>
    <td>ArrangeDataService.getArrangePO(long movieID)</td>
    <td colspan="2">根据电影ID得到一个电影排片详情的PO</td>
   </tr>
   <tr>
    <td>ArrangeDataService.getArrangeList(Date startDate)</td>
    <td colspan="2">根据起始时间得到排片列表</td>
   </tr>
  </table>


(3) 业务逻辑层的动态模型

删除排片信息可以参考添加排片信息的顺序图。



![](https://img-blog.csdnimg.cn/2019050412434085.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxMjYxOA==,size_16,color_FFFFFF,t_70)

<center>图27 添加排片信息的顺序图</center>


根据影厅，电影查看排片信息的顺序图可以参考根据起始时间的顺序图
![](https://img-blog.csdnimg.cn/20190504124508897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxMjYxOA==,size_16,color_FFFFFF,t_70)
<center>图28 查看排片信息（根据起始时间）的顺序图</center>


![](https://img-blog.csdnimg.cn/20190504124352869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxMjYxOA==,size_16,color_FFFFFF,t_70)
<center>图29 设置观众可见时间的顺序图</center>

![](https://img-blog.csdnimg.cn/20190504124442709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAxMjYxOA==,size_16,color_FFFFFF,t_70)
<center>图30 ArrangeblserviceImpl对象的状态图</center>

(4) 业务逻辑层的设计原理

利用任务委任式控制风格，将排片界面需要的业务逻辑经由ArrangeController委任给内部实现类ArrangeblserviceImpl对象。也就是界面分发的任务递交给ArrangeController类，但是不是由ArrangeController直接处理，而是再一次转交给内部实现类处理。



## 7. 依赖视角

[![客户端开发包图.png](https://i.loli.net/2019/05/01/5cc95df3e6ed0.png)](https://i.loli.net/2019/05/01/5cc95df3e6ed0.png)

[![服务器端开发包图.png](https://i.loli.net/2019/05/01/5cc95df4db2a5.png)](https://i.loli.net/2019/05/01/5cc95df4db2a5.png)